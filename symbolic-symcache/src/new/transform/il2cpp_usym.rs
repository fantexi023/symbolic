//! Resolves IL2CPP-compiled native symbols into their managed equivalents using an intermediate
//! mapping file generated by IL2CPP (usym) before writing them to a SymCache.

use symbolic_il2cpp::usym::{UsymSourceRecord, UsymSymbols};

use super::{File, Function, SourceLocation, Transformer};

fn full_path(file: &File<'_>) -> String {
    let comp_dir = file.comp_dir.as_deref().unwrap_or_default();
    let directory = file.directory.as_deref().unwrap_or_default();
    let path_name = &file.name;

    let prefix = symbolic_common::join_path(comp_dir, directory);
    let full_path = symbolic_common::join_path(&prefix, path_name);
    symbolic_common::clean_path(&full_path).into_owned()
}

impl Transformer for UsymSymbols<'_> {
    fn transform_function<'f>(&'f self, f: Function<'f>) -> Function<'f> {
        if let Some(UsymSourceRecord::Mapped(record)) = self.lookup_by_symbol(f.name.to_string()) {
            Function {
                name: record.managed_symbol,
                comp_dir: None,
            }
        } else {
            f
        }
    }

    // todo: if the srcloc includes the symbol name this would be a lot better
    fn transform_source_location<'f>(&'f self, mut sl: SourceLocation<'f>) -> SourceLocation<'f> {
        // TODO: this allocates, which is especially expensive since we run this transformer for
        // every single source location (without dedupe-ing files). It might be worth caching this
        let full_path = full_path(&sl.file);
        if let Some(UsymSourceRecord::Mapped(record)) = self.lookup_by_srcloc(full_path, sl.line) {
            sl.file.name = String::from_utf8_lossy(record.managed_file_info.name);
            sl.file.directory = Some(String::from_utf8_lossy(record.managed_file_info.dir));
            sl.file.comp_dir = None;
            sl.line = record.managed_line;
        }
        sl
    }
}
